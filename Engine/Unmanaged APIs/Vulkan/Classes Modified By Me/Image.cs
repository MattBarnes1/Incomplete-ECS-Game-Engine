/* Please note that this file is generated by the VulkanSharp's generator. Do not edit directly.

   Licensed under the MIT license.

   Copyright 2016 Xamarin Inc

   This notice may not be removed from any source distribution.
   See LICENSE file for licensing details.
*/

using EngineRenderer;
using System;
using System.Runtime.InteropServices;

namespace Vulkan
{
	//TODO: put this in the main Renderer.Vulkan part.
    public class Image : INonDispatchableHandleMarshalling, IDisposable
	{
		internal Image() {}

		internal UInt64 m;
		private VulkanPhysicalDevice Device;
		DeviceMemory deviceMemory;
		public Image(VulkanPhysicalDevice myDevice, ImageCreateInfo pCreateInfo, AllocationCallbacks pAllocator = null)
		{
			this.Device = myDevice;
			Result result;
			unsafe
			{
				fixed (UInt64* ptrpImage = &this.m)
				{
					result = Interop.NativeMethods.vkCreateImage(myDevice.LogicalDevice.m, pCreateInfo != null ? pCreateInfo.m : (Interop.ImageCreateInfo*)default(IntPtr), pAllocator != null ? pAllocator.m : null, ptrpImage);
				}
				if (result != Result.Success)
					throw new ResultException(result);
			}

			MemoryRequirements myRequirements = GetImageMemoryRequirements();

			MemoryAllocateInfo MemInfo = new MemoryAllocateInfo();
			MemInfo.AllocationSize = myRequirements.Size;


			MemInfo.MemoryTypeIndex = myDevice.GetMemoryIndexFromProperty(myRequirements.MemoryTypeBits, MemoryPropertyFlags.DeviceLocal);



			deviceMemory = new DeviceMemory(myDevice.LogicalDevice,MemInfo);
			BindImageMemory(deviceMemory, 0);
		}

		//static object BindMemoryLock()
		public void BindImageMemory(DeviceMemory memory, DeviceSize memoryOffset)
		{
			Result result;
			unsafe
			{
				result = Interop.NativeMethods.vkBindImageMemory(Device.LogicalDevice.m,this.m, memory != null ? memory.m : default(UInt64), memoryOffset);
				if (result != Result.Success)
					throw new ResultException(result);
			}
		}

		public MemoryRequirements GetImageMemoryRequirements()
		{
			MemoryRequirements pMemoryRequirements;
			unsafe
			{
				pMemoryRequirements = new MemoryRequirements();
				Interop.NativeMethods.vkGetImageMemoryRequirements(Device.LogicalDevice.m, this.m, &pMemoryRequirements);
				return pMemoryRequirements;
			}
		}




		public Image(ImageCreateInfo pCreateInfo) : this(VulkanRenderer.SelectedPhysicalDevice, pCreateInfo)
		{
			
		}
		UInt64 INonDispatchableHandleMarshalling.Handle {
			get {
				return m;
			}
		}

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{

					// TODO: dispose managed state (managed objects).
				}

				deviceMemory?.Dispose();
				disposedValue = true;
			}
		}

		// TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
		 ~Image()
		{
			unsafe
			{
				if(Device?.LogicalDevice != null)
					Interop.NativeMethods.vkDestroyImage(Device.LogicalDevice.m, this.m, null);
			}
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(false);
		 }

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
			// TODO: uncomment the following line if the finalizer is overridden above.
			// GC.SuppressFinalize(this); //tells gc not to run finalizer (deconstructor)
		}
		#endregion
	}
}
